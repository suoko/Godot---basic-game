import math

def read_obj(path):
    """
    Reads a .obj file, capturing vertices, texture coordinates, normals,
    faces, and material information.
    """
    vertices = []
    tex_coords = []  # To store texture coordinates (vt)
    normals = []     # To store vertex normals (vn)
    faces = []
    materials = []
    current_material = None
    with open(path, 'r') as f:
        for line in f:
            if line.startswith('v '):
                parts = line.strip().split()
                x, y, z = map(float, parts[1:4])
                vertices.append([x, y, z])
            elif line.startswith('vt '):
                # Read texture coordinates and add them to our list
                parts = line.strip().split()[1:]
                tex_coords.append(parts)
            elif line.startswith('vn '):
                # Read vertex normals and add them to our list
                parts = line.strip().split()[1:]
                normals.append(parts)
            elif line.startswith('f '):
                # Store the entire face definition (e.g., "v/vt/vn")
                # to preserve all data.
                parts = line.strip().split()[1:]
                faces.append((parts, current_material))
            elif line.startswith('usemtl '):
                current_material = line.strip().split()[1]
            elif line.startswith('mtllib '):
                materials.append(line.strip().split()[1])
    return vertices, tex_coords, normals, faces, materials

def write_obj(path, vertices, tex_coords, normals, faces, materials):
    """
    Writes a .obj file, including vertices, texture coordinates, normals,
    faces, and material information.
    """
    with open(path, 'w') as f:
        f.write('# Generated by scaling script\n')
        # Write material library reference
        for mat_lib in materials:
            f.write(f'mtllib {mat_lib}\n')

        # Write all vertex, texture coordinate, and normal data
        for v in vertices:
            f.write(f'v {v[0]} {v[1]} {v[2]}\n')
        for vt in tex_coords:
            f.write(f'vt {" ".join(vt)}\n')
        for vn in normals:
            f.write(f'vn {" ".join(vn)}\n')

        current_mat = None
        # Write face data, ensuring material groups are correct
        for face_parts, mat in faces:
            if mat != current_mat:
                # Only write usemtl if the material is not None
                if mat:
                    f.write(f'usemtl {mat}\n')
                current_mat = mat
            # Join the original face parts to reconstruct the line
            face_str = ' '.join(face_parts)
            f.write(f'f {face_str}\n')

def compute_base(vertices, threshold=0.01):
    min_y = min(v[1] for v in vertices)
    base_vertices = [v for v in vertices if abs(v[1] - min_y) < threshold]
    return base_vertices

def compute_scale_factor(base_a, base_b):
    def bbox(vertices):
        if not vertices:
            return {'min_x': 0, 'max_x': 0, 'min_z': 0, 'max_z': 0}
        xs = [v[0] for v in vertices]
        zs = [v[2] for v in vertices]
        return {
            'min_x': min(xs), 'max_x': max(xs),
            'min_z': min(zs), 'max_z': max(zs)
        }
    bbox_a = bbox(base_a)
    bbox_b = bbox(base_b)
    
    delta_x_a = bbox_a['max_x'] - bbox_a['min_x']
    delta_z_a = bbox_a['max_z'] - bbox_a['min_z']
    
    if delta_x_a == 0 or delta_z_a == 0:
        raise ValueError("Error: Base 'A' has zero size in one dimension. Cannot compute scale factor.")

    scale_x = (bbox_b['max_x'] - bbox_b['min_x']) / delta_x_a
    scale_z = (bbox_b['max_z'] - bbox_b['min_z']) / delta_z_a
    return (scale_x, scale_z)

def scale_vertices(vertices, scale_x, scale_z, center):
    scaled = []
    for v in vertices:
        dx = v[0] - center[0]
        dz = v[2] - center[2]
        scaled_v = [
            center[0] + dx * scale_x,
            v[1],
            center[2] + dz * scale_z
        ]
        scaled.append(scaled_v)
    return scaled

# --- Main Execution ---

# Read input files using the updated function
house_vertices, house_tex_coords, house_normals, house_faces, house_materials = read_obj('SquareHouseA.obj')
pyramid_vertices, _, _, _, _ = read_obj('pyramid.obj')

# Extract bases
house_base = compute_base(house_vertices)
pyramid_base = compute_base(pyramid_vertices)

# Compute scaling factors
scale_x, scale_z = compute_scale_factor(house_base, pyramid_base)

# Compute center of house base
center_x = (min(v[0] for v in house_base) + max(v[0] for v in house_base)) / 2
center_z = (min(v[2] for v in house_base) + max(v[2] for v in house_base)) / 2
center = [center_x, 0, center_z]

# Scale house vertices
scaled_house_vertices = scale_vertices(house_vertices, scale_x, scale_z, center)

# Write scaled OBJ with original materials, texture coordinates, and normals
output_obj_path = 'scaled_SquareHouseA_with_materials.obj'
write_obj(output_obj_path, scaled_house_vertices, house_tex_coords, house_normals, house_faces, house_materials)

# Copy and rename original MTL file to match the new OBJ file
if house_materials:
    # Assuming the first material library is the one we need.
    original_mtl_path = house_materials[0]
    output_mtl_path = 'scaled_SquareHouseA_with_materials.mtl'
    try:
        with open(output_mtl_path, 'w') as f_out, open(original_mtl_path, 'r') as f_in:
            f_out.write(f_in.read())
        print(f"Successfully created '{output_obj_path}' and '{output_mtl_path}'")
    except FileNotFoundError:
        print(f"Warning: Could not find material file '{original_mtl_path}'. The .obj file was created but materials may be missing.")